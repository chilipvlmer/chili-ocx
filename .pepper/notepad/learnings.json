{
  "version": "1.0.0",
  "entries": [
    {
      "timestamp": "2026-01-18T21:24:07.075Z",
      "content": "**Dev Branch Testing Workflow for Chili-OCX**\n\nWhen developing chili-ocx itself (meta-development):\n\n**Setup (One-time):**\n1. Create dev branch: `git checkout -b dev-feature-name`\n2. Build branch: `./scripts/build-branch.sh dev-feature-name`\n3. Create isolated ghost profile: `ocx ghost profile add dev-feature`\n4. Switch to dev profile: `ocx ghost profile use dev-feature`\n5. Add dev registry: `ocx ghost registry add file:///Users/chili/•KOKPIT•/•PROGRAMOWANIE•/chili-ocx/dist-dev-feature-name --name dev-feature`\n6. Install components: `ocx ghost add dev-feature/pepper-harness`\n\n**Iterative Development:**\n1. Make code changes in the repo\n2. Rebuild: `./scripts/build-branch.sh dev-feature-name`\n3. Switch profile: `ocx ghost profile use dev-feature`\n4. Restart OpenCode: `ocx ghost opencode`\n5. Test changes\n6. Repeat\n\n**Profile Management:**\n- Production profile: `pepper-harness` (uses https://chili-ocx.pages.dev)\n- Dev profiles: Custom per branch (uses local file:// registry)\n- Switch: `ocx ghost profile use <name>`\n- List: `ocx ghost profile list`\n\n**When to Full Reset:**\n- Adding/removing components from registry.jsonc: Remove and re-add registry\n- Changing component structure: Reinstall with `ocx ghost add`\n- Code/prompt changes only: Just rebuild + restart OpenCode"
    },
    {
      "timestamp": "2026-01-18T21:37:48.993Z",
      "content": "**Testing Strategy for OCX Ghost Commands**\n\nWhen testing commands like `ocx ghost opencode` that launch interactive sessions:\n- Use **tmux parallel terminal instances** with reasonable timeouts\n- Don't run interactively - agents will wait indefinitely and get stuck\n- Example approach:\n  ```bash\n  # Start OpenCode in background tmux session\n  tmux new-session -d -s test-ghost \"ocx ghost opencode\"\n  sleep 5  # Wait for startup\n  # Run test commands\n  tmux send-keys -t test-ghost \"test command here\" C-m\n  # Check results with timeout\n  timeout 30s tmux capture-pane -t test-ghost -p\n  # Cleanup\n  tmux kill-session -t test-ghost\n  ```\n- This prevents blocking and allows automated testing of interactive workflows"
    },
    {
      "timestamp": "2026-01-18T21:39:54.490Z",
      "content": "**Automated Testing Strategy for Interactive OCX Commands**\n\nWhen writing tests for chili-ocx that involve interactive commands (e.g., `ocx ghost opencode`, `ocx ghost add`), use **tmux with timeouts** to prevent blocking:\n\n**Standard Pattern:**\n```bash\ntest_interactive_command() {\n  local session=\"test-$$\"\n  \n  # 1. Start in background tmux\n  tmux new-session -d -s \"$session\" \"ocx ghost opencode\"\n  sleep 5  # Startup time\n  \n  # 2. Send commands\n  tmux send-keys -t \"$session\" \"/command-to-test\" C-m\n  sleep 2\n  \n  # 3. Capture with timeout\n  timeout 30s tmux capture-pane -t \"$session\" -p > output.txt\n  \n  # 4. Verify results\n  grep -q \"expected output\" output.txt\n  \n  # 5. Always cleanup (even on failure)\n  tmux kill-session -t \"$session\" 2>/dev/null || true\n}\n```\n\n**Key Guidelines:**\n- Never run interactive OCX commands directly in tests - they block indefinitely\n- Use unique session names (e.g., `test-$$` with PID)\n- Set reasonable timeouts: 5s startup, 30s max per test\n- Always cleanup tmux sessions (use trap handlers for failures)\n- Capture output for debugging failed tests\n- Alternative: use `expect/pexpect` for complex multi-step interactions\n\n**Why This Matters:**\n- Prevents CI/CD pipeline hangs\n- Enables automated testing of the full Ghost workflow\n- Allows parallel test execution\n- Makes tests reproducible and reliable"
    },
    {
      "timestamp": "2026-01-18T21:44:09.150Z",
      "content": "**Feature Idea: Link .pepper/notepad to GitHub Issues**\n\nEnable agents to create GitHub issues/PRs directly from notepad entries (learnings, issues, decisions).\n\nUse cases:\n- Convert notepad issues → GitHub bug reports\n- Convert learnings → Documentation PRs\n- Convert decisions → Architecture discussion issues\n\nBenefits: Seamless transition from local development notes to public issue tracking.\n\nWorth exploring: GitHub API integration, issue templates, automatic linking."
    },
    {
      "timestamp": "2026-01-18T22:51:32.835Z",
      "content": "State Management: Ownership was unclear during RFC-001/002/003. Root cause: state.json is minimalist and doesn't track workflow. Solution direction: Use file structure as state (plan.md, RFC status fields) rather than duplicating in state.json. Convention over configuration approach - derive state by reading files rather than maintaining separate state object. This eliminates sync issues and provides single source of truth."
    },
    {
      "timestamp": "2026-01-18T22:51:51.651Z",
      "content": "Testing Timing: Tests written in RFCs but executed after implementation. Root cause: No test framework + manual testing approach. Achieved 100% pass rate but testing was post-implementation rather than TDD. Solution: Hybrid approach - critical code gets test-first treatment (even if .skip), documentation gets manual testing. Match testing rigor to risk level. Consider future RFC for test infrastructure setup."
    },
    {
      "timestamp": "2026-01-18T22:52:12.394Z",
      "content": "Notepad Usage: Exists but underutilized during RFC-001/002/003. Root cause: No workflow integration in agent prompts, manual entry required, unclear value proposition. Solution: Add notepad review to agent prompts (Seed checks learnings before RFCs, Habanero adds review findings). Consider structured format with tags and relevance indicators. The irony: We're using notepad NOW to document that notepad is underused!"
    },
    {
      "timestamp": "2026-01-18T22:52:35.856Z",
      "content": "Progress Visibility: Hard to see PRD-level completion during RFC-001/002/003. Root cause: Excellent task-level tracking (plan.md checkboxes) but no high-level view. Solution: Enhance plan.md header with PRD progress (3/5 RFCs = 60%), derive from RFC status fields in files. Consider progress visualization command (pepper_status --verbose) showing phase completion and RFC tree."
    },
    {
      "timestamp": "2026-01-18T22:58:16.088Z",
      "content": "Progress Visibility (UPDATED): The real issue isn't lack of visibility - it's that we're using plan.md checkboxes instead of OpenCode's native todolist UI. OpenCode has todowrite/todoread tools that agents can use, but usage is inconsistent (Jalapeño used it for RFC-003 then abandoned, leaving stale completed todos). Solution: Context-aware todo management - Scoville shows PRD progress, Seed shows RFC progress, Sprout/Jalapeño show execution plan. Need workflow convention: agents should clear old todos and write context-appropriate todos at session start. This provides better UX (dedicated UI panel) and leverages existing OpenCode infrastructure."
    },
    {
      "timestamp": "2026-01-18T23:00:02.882Z",
      "content": "Notepad Consolidation Pattern: When brainstorming revealed duplicate/related issues (Progress Visibility + earlier Plan-TODO Desync), consolidated into single comprehensive issue entry. This prevents notepad bloat and creates better reference material. Pattern: Read existing issues first, identify overlap, merge with enhanced solution. Result: Single \"State Management & Todo Integration\" issue now captures full problem space with concrete solution proposals."
    },
    {
      "timestamp": "2026-01-19T18:54:30.401Z",
      "content": "**Session Initialization Should Check Full .pepper/ Context**\n\nProblem: Scoville only reads state.json at session start, missing the actual project state in plan.md, rfc-status.json, and archived plans.\n\nRoot cause: Following \"file structure as state\" philosophy but not reading those files during initialization.\n\nSolution: Session init should check (in order):\n1. state.json - Session tracking\n2. plan.md - Current plan status and next steps\n3. tracking/rfc-status.json - RFC progress\n4. notepad/*.json - Recent learnings/issues/decisions\n5. specs/prd/*.md - Active PRD (if any)\n\nThis enables context-aware suggestions like:\n- \"You have 3 RFCs ready to implement\" (from plan.md)\n- \"RFC-003 is next based on dependencies\" (from plan.md + rfc-status.json)\n- \"Your last session noted X issue\" (from notepad)\n\nImplementation: Update Scoville agent prompt to include pepper_status call or multi-file read at session start."
    },
    {
      "timestamp": "2026-01-19T18:58:54.228Z",
      "content": "**Intelligent Session Initialization with Context Analysis**\n\nEnhancement to previous learning: Don't just read .pepper/ files - ANALYZE them and provide intelligent recommendations.\n\nAt session start, Scoville should:\n\n1. **Gather context** (multi-file read):\n   - state.json - Session state\n   - plan.md - Active plan and next steps\n   - tracking/rfc-status.json - RFC progress\n   - notepad/issues.json - Recorded problems\n   - notepad/learnings.json - Recent insights\n   - notepad/decisions.json - Past choices\n   - specs/prd/*.md - Active PRD (if any)\n\n2. **Analyze and correlate**:\n   - Compare issues with RFC status (are issues addressed by planned RFCs?)\n   - Identify blocking issues vs. nice-to-haves\n   - Find dependencies (which RFC should be next based on blockers?)\n   - Surface recent learnings relevant to next steps\n   - Detect stale work (RFCs drafted but not implemented for >7 days)\n\n3. **Present intelligent summary**:\n   - \"You have X open issues: [summarize top 3]\"\n   - \"RFC-003 is recommended next because it addresses issue #2 and unblocks RFC-005\"\n   - \"Recent learning: [relevant insight from notepad]\"\n   - \"Last session completed RFC-002, next logical step is...\"\n\n4. **Offer prioritized options**:\n   - [Recommended] Continue RFC-003 (addresses issues X, Y)\n   - Review open issues (3 recorded)\n   - Start new work\n   - Review learnings\n\nThis transforms Scoville from passive coordinator to active project manager who understands context and guides effectively."
    },
    {
      "timestamp": "2026-01-19T20:12:46.040Z",
      "content": "**Comprehensive Branch Testing Strategy Success (2026-01-19)**\n\nSuccessfully tested dev-symlink-detection branch covering 3 RFCs with 100% automated test pass rate.\n\n**Approach**:\n- Created structured testing plan (7 phases, 18 tests)\n- Used direct function testing for unit-level verification\n- Used static file analysis for configuration/documentation verification\n- Documented what cannot be tested (interactive workflows) vs what was tested\n\n**Key Techniques**:\n1. Direct Node.js function testing: `node -e \"const { func } = require('...')\"` for workspace utilities\n2. Bash scripting for multi-step test scenarios (create symlink, test, cleanup)\n3. Static verification: grep/pattern matching for agent prompt content\n4. Integration verification: Code review of imports and usage patterns\n\n**Results**:\n- 18/18 tests passed (100%)\n- 16/22 acceptance criteria fully met (73%)\n- 6/22 partial/deferred (27% - all acceptable per RFCs)\n- 0 critical bugs found\n- 0 regressions detected\n\n**What worked well**:\n- Direct function testing is fast and reliable\n- Temporary test directories with cleanup prevent pollution\n- Structured test plan keeps testing organized\n- Comprehensive test report provides merge confidence\n\n**Limitations identified**:\n- Interactive Ghost workflow testing difficult to automate\n- Some acceptance criteria require live sessions to verify\n- Cross-platform testing requires CI/CD infrastructure\n\n**Recommendation for future**: This testing pattern (structured plan + automated unit tests + static verification + comprehensive report) should be standard for all branch testing."
    },
    {
      "timestamp": "2026-01-19T20:16:27.851Z",
      "content": "**CRITICAL: End-to-End Registry Installation Testing Required (2026-01-19)**\n\n**Issue Discovered**: During dev-symlink-detection branch testing, we verified code functionality and build process but FAILED to test actual installation and launch of the pepper-harness from the dev registry.\n\n**What We Tested**:\n- ✅ Direct function testing (workspace utilities work)\n- ✅ Build process (bun run build succeeds)\n- ✅ Static file verification (agent prompts have correct content)\n\n**What We MISSED**:\n- ❌ Installing pepper-harness from local file:// registry into fresh Ghost profile\n- ❌ Actually launching Ghost OpenCode with the new components\n- ❌ Verifying tools (pepper_init, pepper_status) work in live session\n- ❌ Confirming agent prompts load correctly in OpenCode\n- ❌ Testing that registry index.json is valid and components are discoverable\n\n**Why This Matters**:\n- Build could succeed but produce broken runtime code\n- Registry could be malformed\n- Component metadata could be incorrect\n- Runtime errors could exist that unit tests don't catch\n- Users installing from the registry would get broken components\n\n**MANDATORY Test Phase for All Future Development**:\n\n### Phase X: End-to-End Installation & Launch Test\n\n1. **Create completely fresh Ghost profile**\n   ```bash\n   PROFILE=\"test-e2e-$(date +%s)\"\n   ocx ghost profile add \"$PROFILE\"\n   ocx ghost profile use \"$PROFILE\"\n   ```\n\n2. **Add local dev registry**\n   ```bash\n   ocx ghost registry add \"file:///path/to/repo/dist\" --name dev-test\n   ```\n\n3. **Verify components are discoverable**\n   ```bash\n   ocx ghost search dev-test\n   # Should show all 40 components\n   ```\n\n4. **Install pepper-harness (handle conflicts if needed)**\n   ```bash\n   # May need to remove existing installations first\n   ocx ghost add dev-test/pepper-plugin\n   ocx ghost add dev-test/scoville-orchestrator\n   # ... install all required components\n   ```\n\n5. **Launch Ghost OpenCode**\n   ```bash\n   # Use tmux to prevent blocking\n   tmux new-session -d -s test-ghost \"ocx ghost opencode\"\n   sleep 5\n   ```\n\n6. **Test tools in live session**\n   ```bash\n   # Send commands to tmux session\n   tmux send-keys -t test-ghost \"/pepper-init\" C-m\n   sleep 2\n   tmux send-keys -t test-ghost \"/pepper-status\" C-m\n   sleep 2\n   \n   # Capture and verify output\n   tmux capture-pane -t test-ghost -p | grep \"✅\"\n   ```\n\n7. **Test agent switching**\n   ```bash\n   # Test TAB completion works\n   # Test agents load with updated prompts\n   # Test workflow handoffs appear\n   ```\n\n8. **Cleanup**\n   ```bash\n   tmux kill-session -t test-ghost\n   ocx ghost profile use pepper-harness  # switch back\n   ocx ghost profile remove \"$PROFILE\"\n   ```\n\n**Consequence of Skipping This**:\n- Could ship broken builds to production\n- Users would download and install broken components\n- Runtime errors only discovered by users\n- Regression testing insufficient\n\n**Priority**: P0 - CRITICAL\n\n**Action**: Update all future testing plans to include \"Phase X: E2E Installation & Launch\" as mandatory step before merge recommendation.\n\n**Related**: Testing plan template, RFC testing protocols, merge checklist"
    },
    {
      "timestamp": "2026-01-19T20:30:08.018Z",
      "content": "**META-LEARNING: Ghost Workspace Architecture Understanding (2026-01-19)**\n\n**CRITICAL DISCOVERY**: We've been running INSIDE a Ghost workspace the entire time!\n\n**Current Situation**:\n- This testing session is running in: `/private/var/folders/d_/wh31y1w9375chrn4kyl3yzkc0000gn/T/ocx-ghost-49067cbd`\n- This is a symlinked Ghost workspace (symlink detection working!)\n- ALL Ghost profiles share THIS workspace's `.opencode/` directory\n- Components are installed at: `./opencode/plugin/`, `./.opencode/agent/`, `./.opencode/skill/`\n\n**How Ghost Profiles Work**:\n1. Ghost creates ONE workspace per `ocx ghost opencode` session (in /tmp)\n2. Profiles control which REGISTRIES are active\n3. Profiles control which AGENTS are available\n4. But ALL profiles share the SAME component installation directory (`.opencode/`)\n5. This means profiles DON'T provide component isolation\n\n**Implications for E2E Testing**:\n1. Cannot test \"clean installation\" in current Ghost session (already has components)\n2. Need to either:\n   - Exit Ghost and start completely fresh session\n   - OR: Delete `.opencode/` directory and reinstall\n   - OR: Test in separate terminal/environment\n\n**Correct E2E Testing Procedure**:\n1. EXIT current Ghost workspace session\n2. Start NEW Ghost session: `ocx ghost opencode` (creates fresh /tmp workspace)\n3. THEN create profile and install components\n4. This gives truly clean `.opencode/` for testing\n\n**Why This Matters**:\n- Explains profile behavior we observed\n- Clarifies component installation mechanics\n- Shows that workspace != profile\n- Indicates need for session management in E2E testing\n\n**Action**: Update E2E testing protocol to account for Ghost session management\n\n**Priority**: P0 - Fundamental to E2E testing methodology"
    },
    {
      "timestamp": "2026-01-19T20:31:49.309Z",
      "content": "**SOLUTION: How to Create Fresh Ghost Session for E2E Testing (2026-01-19)**\n\n**Problem**: Need fresh `.opencode/` directory to test clean component installation\n\n**How Ghost Workspaces Work**:\n1. Each `ocx ghost opencode` creates a NEW workspace: `/tmp/ocx-ghost-XXXXXXXX/`\n2. Workspace contains:\n   - `.opencode/` directory (REAL, contains installed components)\n   - `.pepper/` directory (REAL, local state)\n   - Most project files (SYMLINKS → actual repo)\n3. Each workspace has its OWN `.opencode/` directory\n4. Profiles are SHARED across workspaces\n\n**Solution for Fresh E2E Testing**:\n\n**Option A: Delete Current .opencode (Quick)**\n```bash\n# In current Ghost workspace\nrm -rf .opencode/\n# Now can test fresh installation\n```\n\n**Option B: New tmux Ghost Session (Clean)**\n```bash\n# In a NEW terminal or tmux window\ntmux new-session -d -s fresh-e2e \"ocx ghost opencode\"\nsleep 5\n\n# This creates: /tmp/ocx-ghost-XXXXXXXX/ with fresh .opencode/\n# Connect to it:\ntmux attach -t fresh-e2e\n```\n\n**Option C: New Ghost Session with Profile**\n```bash\n# Start fresh Ghost with specific profile\nocx ghost opencode --profile test-e2e-TIMESTAMP\n\n# This creates new workspace automatically\n```\n\n**For E2E Testing Protocol**:\n1. Start: `tmux new-session -d -s e2e-test \"ocx ghost opencode\"`\n2. Wait: `sleep 10` (allow startup)\n3. Find workspace: Check `/tmp/` for newest `ocx-ghost-*`\n4. Test: Install components to fresh `.opencode/`\n5. Cleanup: `tmux kill-session -t e2e-test`\n\n**Key Insight**: `.opencode/` is workspace-local, NOT profile-local\n\n**Status**: RESOLVED - Method identified"
    }
  ]
}